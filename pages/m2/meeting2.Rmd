---
title: "2: მონაცემთა მანიპულაცია"
output:
  html_notebook: default
bibligraphy: bibliography.bib
---

#### ![](ico/flask-outline.png) გეგმა:

* მონაცემების წაკითხვა R-გარემოში

* მონაცემთა ტიპები და ვექტორული ობიექტები
	+ ატომური ობიექტები (სიმბოლო, ლოგიკური, მთელი და ათწილადი რიცხვები)
	+ სია
	+ ატრიბუტი
	+ ფაქტორი
	+ მასივი და მატრიცა
	+ მონაცემთა ჩარჩო
	
* არითმეტიკული ფუნქციები და ოპერატორები

* მონაცემთა დამუშავება
	+ ქვესიმრავლის ამორჩევა,
	+ მონაცემთა ჩასმა

* შემთხვევით რიცხვთა გენერირების ალგორითმები
* შერჩევა
	
![](ico/book.png) მეორე დავალება ატვირთეთ ამ [ბმულზე](https://www.dropbox.com/request/gkLTQPwL5nmYafi2Hli9)

### საკითხავი მასალა ლაბორატორიული სამუშაოსთვის

წინამდებარე თავი ეფუძნება ჰედლი უიქჰემის წიგნს [Advanced R](http://adv-r.had.co.nz/Data-structures.html), ჯონ ვერზანის ,,simpleR''-ს და DataCamp-ის [სახელმძღვანელოს](https://www.datacamp.com/community/tutorials/r-data-import-tutorial)

#### მონაცემების წაკითხვა R-გარემოში

R-გარემოში ანალიზისთვის სხვადასხვა ფორმატის მონაცემების გამოყენებაა შესაძლებელი, მათ შორის, ექსელის, ტექსტური ფაილების, Stata, SPSS, SAS, SQL ცხრილების, სივრცითი მონაცემების ფაილების (.shp), ჯავასკრიპტის ნოტაციის დოკუმენტების (.json) და ა.შ. თავად ფაილები შესაძლებელია, თქვენს კომპიუტერში ინახებოდეს, ან - ინტერნეტის მეშვეობით იყოს ხელმისაწვდომი.

##### მონაცემების წაკითხვა ჩაშენებული ფუნქციების მეშვეობით

როგორც წესი, მონაცემები ცხრილურ ფორმატშია წარმოდგენილი, სადაც თითოეული სტრიქონი ჩანაწერს, ხოლო - სვეტი - ცვლადს აღნიშნავს. მართალია, მონაცემთა ორგანიზების სხვა პარადიგმებიც არსებობს (მაგ. tidy data, დოკუმენტთა ბაზები, რელაციური ცხრილები და ა.შ.), მაგრამ მათ ამჯერად არ შევეხებით.

ჩაშენებული ფუნქციების მეშევეობით ყველაზე იოლად მძიმით ან ტაბის სიმბოლოთი გამოყოფილი ცხრილების წაკითხვა შეიძლება. ასეთი მონაცემები, როგორც წესი, ტექსტურ ფაილებში ინახება, რომლებსაც `.csv`, `.txt` ან `.dat` გაფართოება აქვთ. თავად ფაილთა ,,შიგთავსი'' მარტივი აღსაქმელია:

```{r, eval=FALSE}

### ტაბით გამოყოფილი ცხრილი

1   6   a
2   7   b
3   8   c
4   9   d
5   10  e

### მძიმით გამოყოფილი ცხრილი

v1,v2,v3
1,2,3
4,5,6
7,8,9
a,b,c


```

დირექტორიის მითითებით ცხრილის პროგრამის მეხსიერებაში ობიექტის სახით შემოტანა შემდეგი სინტაქსის საშუალებით ხდება:

```{r, eval=FALSE}
myTable<-read.table("data/myTable.txt")
```
ცხრილების შემოტანისას, დამატებითი პარამეტრების მითითებაც შეგვიძლია, მაგალითად, პირველი რიგის ცვლადის სახელებად მითითება, სვეტების გამოყოფის სიმბოლოს აღნიშვნა და ა.შ.:

```{r, eval=FALSE}
myTable<-read.table("data/myTable.txt", header = TRUE, sep=",") ### მძიმით გამოყოფილი ცხრილის წაკითხვა

myTable<-read.table("data/myTable.txt", header = TRUE, sep="\t") ### ტაბით გამოყოფილი ცხრილის წაკითხვა
```

მძიმით გამოყოფილი ცხრილების წაკითხვისთვის ცალკე ფუნქცია არსებობს, რომლის გამოყენებისას `sep=","` პარამეტრის მითითება აღარ გვჭირდება:

```{r, eval=FALSE}
myTable<-read.csv("data/myTable.csv", header=TRUE) ### მძიმით გამოყოფილი ცხრილის წაკითხვა

```

ონლაინ არსებული ტექსტური ცხრილების წასაკითხად იგივე სინტაქსს ვიყენებთ, ოღონდ კომპიუტერში არსებული ფაილის მისამართის ნაცვლად, ვებგვერდისას ვუთითებთ:

```{r, eval=FALSE}
```

```{r, eval=FALSE}
galton<-read.csv("https://vincentarelbundock.github.io/Rdatasets/csv/HistData/Galton.csv")

```

##### მონაცემების წაკითხვა გარე ბიბლიოთეკების მეშვეობით

თუკი R-გარემოში ექსელის ცხრილის შემოტანა გსურთ, ამისთვის სპეციალური ბიბლიოთეკები უნდა გამოიყენოთ. პირევლ რიგში, ისინი უნდა დააინსტალიროთ და შემდეგ გამოიძახოთ:

```{r, eval=FALSE}
install.packages("XLConnect")
install.packages("readxl")

library(XLConnect)
library(readxl)

```

ტექსტური ფაილებისგან განსხვავებით, ექსელის ცხრილების წაკითხვისას საჭირო გვერდის სახელი ან რიგითი ნომერი უნდა მივუთითოთ. მათი სინტაქსი ბიბლიოთეკების მიხედვით ოდნავ განსხვავებულია


```{r, eval=FALSE}

### XLConnect ბიბლიოთეკა:

xl<-loadWorkbook("data/myxlfile.xlsx")
xldata<-readWorksheet(xl, sheet=1)

### readxl ბიბლიოთეკა:

xldata<-read_excel("data/myxlfile", "mysheetname") ### ან
xldata<-read_excel("data/myxlfile", 1)

```

გარე ბიბლიოთეკის გამოყენება გვჭირდება SPSS და STATA მონაცემების წაკითხვისთვისაც:

```{r, eval=FALSE}
install.packages("foreign")
library(foreign)

savData<-read.spss("data/spssfile.sav")

dtaData<-read.dta("data/statafile.dta")

```

#### მონაცემთა ტიპები და ვექტორული ობიექტები

R-გარემოში მონაცემები წარმოადგენენ ვექტორებს ანუ მნიშვნელობა აქვს მონაცემების შეყვანის თანმიმდევრობას - პირველად შეყვანილი რიცხვი წარმოადგენს პირველ ელემენტს, მეორე - მომდევნოს და ა.შ. მაგალითად:

```{r, eval=FALSE}
eList<-c("მე პირველი ელემენტი ვარ", "მე მეორე ელემენტი ვარ", "მე მესამე ელემენტი ვარ")

```

`eList` ობიექტს სამი ელემენტს გააჩნია. რახან იგი ვექტორია, შეგვიძლია, მის შემადგენელ ნაწილებს ცალ-ცალკე მივმართოთ და სურვილისამებრ გამოვიძახოთ:

```{r}
eList[1] ### პირველი ელემენტი

eList[2] ### მეორე ელემენტი

eList[3] ### მესამე ელემენტი

```

##### ატომური ობიექტები

ატომური ობიექტები ისეთი ობიექტებია, რომელსაც _ერთი განზომილება_ გააჩნიათ: ისინი სიმბოლოების თანმიმდევრობას წარმოადგენენ და ასეთი ობიექტის თითოეულ ელემენტს თავისი რიგითი ნომერი გააჩნია. ყველაზე ხშირად შემდეგი ატომური ობიექტები გამოიყენება: ლოგიკური, მთელი რიცხვები, ათწილადი რიცხვები და სიმბოლოები. ატომური ობიექტების შექმნა `c()` სუფიქსის მეშვეობით ხდება:

```{r}

logical<-c(TRUE, FALSE, T, F)
integer<-c(1L, 4L, 8L, 0L)
double<-c(1, 3.6, 90, 4)
characters<-c("a", "b", "სამი", "four")

```


##### სია

სია წარმოადგენს ერთი ან რამდენიმე ატომური ობიექტის ან მათი ერთობლიობის კომბინაციას. მისი აგება ხდება `list()` სუფიქსის მეშვეობით:

```{r}

simpleList<-list(TRUE, FALSE, T, F)
combiList<-list(c("a", "b"), c("იყო არაბეთს როსტევან"), c(1L, 4L, 8L, 0L), 98)
multidimList<-list(list(c("a", "b"), 7), c("რომელმან შექმნა სამყარო"))

```

##### ატრიბუტი

ატრიბუტი წარმოადგენს ობიექტის დამატებით ელემენტს, სადაც შეგვიძლია, მივუთითოთ მისი ტიპი, სახელწოდება და ა.შ. R-გარემოში ობიექტებისთვის შემდეგი ატრიბუტებია დაშვებული:

| __ატრიბუტი__ | __აღწერა__ |
|--------------|--------------------------------------------------------------------------------|
|	`class`		| ობიექტის ან მისი ელემენტის ტიპი|
|	`comment` 	| ობიექტის ტექსტური კომენტარი, მაგ. მისი აღწერა, დანიშნულება და ა.შ.|
|	`dim`		| აღნიშნული ატრიბუტი შეესაბამება ცხრილური ტიპის ობიექტებს (მატრიცებს, მონაცემთა ჩარჩოებს, მასივებს) და აღნიშნავს მის განზომილებებს ანუ რიგების და სვეტების რაოდენობა|
|	`dimnames` | `dim` ატრიბუტის მსგავსად, `dimnames` მხოლოდ ცხრილური ტიპის ობიექტებს გააჩნიათ და მისი საშუალებით შესაძლებელია, განზომილებების (ანუ რიგის და სვეტის) სახელებზე მიმართვა|
|	`names`	| ობიექტის სახელწოდება |
|	`row.names` | ცხრილური ტიპის ობიექტის რიგების სახელი |
|	`tsp`		| დროის მწკრივების ტიპის ობიექტის საწყისი, დასასრული დროები და მნიშვნელობა |
|	`levels`	| ფაქტორული ტიპის ობიექტების დონეები. მარტივად რომ ვთქვათ, მნიშვნელობის განსაზღვრებები, როგორიც SPSS და STATA-ს ცვლადებს გააჩნიათ |

როგორც წესი, ობიექტს რამდენიმე ატრიბუტი გააჩნია. ცალკეული ატრიბუტის მინიჭება შესაძლებელია $attr$ ბრძანების მეშვეობით. თუკი გვსურს, მივმართოთ ყველა ატრიბუტს, მაშინ უნდა გამოვიყენოთ $attributes$ ბრძანება:

```{r}
attr(x, "Attribute") <- "ატრიბუტი"

attributes(x)

```

როგორც ზემოთ ვახსენეთ, `names` ერთ-ერთი ატრიბუტია, თუმცა მისი გამოყენება ხშირად დაგვჭირდება. ამ ატრიბუტის მარტივი, თუმცა არცთუ ზუსტი ანალოგია სხვა სტატისტიკურ პროგრამებში გამოყენებული ცვლადის სახელებია. `names` ატრიბუტის მინიჭება შემდეგი სინტაქსის მეშვეობით ხდება:

```{r}
myObject<- c(10, 20, 30)
names(myObject) <- c("ასაკი", "სიმაღლე", "წონა")

```

##### ფაქტორი

ფაქტორი ობიექტის სპეციფიური ტიპია, რომელსაც მხოლოდ წინასწარ განსაზღვრული მნიშვნელობების მიღება შეუძლია. ფაქტორული ობიექტის მაგალითია ცვლადი, რომელიც რესპონდენტის თვალის ფერს აღნიშნავს. აქ დასაშვები მნიშვნელობების სიმრავლე შეზღუდულია: 1 შეესაბამება "თაფლისფერს", 2 - "მწვანეს", 3 "ცისფერს", 4 "ნაცრისფერს" და ა.შ. დასაშვები მნიშვნელობები უკვე ნახსენები `levels` ატრიბუტის მეშვეობით განისაზღვრება:

```{r}

eyes<-factor(c(1, 2, 3, 4), levels=c("თაფლისფერი", "მწვანე", "ცისფერი", "ნაცრისფერი"))

```

##### მონაცემთა მასივი და მატრიცა

![](img/bullets.gif)


ჩვენს მიერ აქამდე განხილული მონაცემთა ტიპები ერთგანზომილებიანია, თუმცა პრაქტიკაში როგორც წესი, საქმე მრავალგანზომილებიან მონაცემებთან, მაგალითად - ცხრილებთან გვაქვს. მონაცემთა მასივის ტიპის ობიექტები (`array`) სწორედ ამ ამოცანის გადაწყვეტას ემსახურებიან. ერთგანზომილებიანი ობიექტებისგან განსხვავებით, რომლებსაც მარტივი ენით რომ ვთქვათ, მხოლოდ სიგრძე გააჩნიათ, მონაცემთა მასივებს ,,სიგანეც'' ახასიათებთ. კერძოდ, ორი ერთგანზომილებიანი ობიექტის კომბინირებით შესაძლებელია, მატრიცული ტიპის ცხრილის მიღება:

```{r}
a<-c(1, 2)
b<-c(10, 20, 30, 40, 50, 60)

ab.array<-array(c(a, b), dim=c(3, 3, 2))
print(ab.array)

```

ჩვენს განკარგულებაში ორი, 3x3 _მატრიცისგან_ შემდგარი მონაცემთა მასივია. მონაცემთა მასივის განზომილებები `array` ფუნქციის `dim` ატრიბუტით მივუთითეთ. მონაცემთა მასივს შესაძლოა, სხვა ატრიბუტებიც გააჩნდეს, მაგალითად - სვეტების, სტრიქონების და შემადგენელი მატრიცების სახელწოდებები:

```{r}
a<-c(1, 2)
b<-c(10, 20, 30, 40, 50, 60)
column.name <-c("სვეტი1", "სვეტი2", "სვეტი3")
row.name <- c("სტრიქონი1", "სტრიქონი2", "სტრიქონი3")
matrix.name<- c("Thomas Anderson", "Neo")
ab.array <- array(c(a,b),dim = c(3,3,2),dimnames = list(row.name, column.name, matrix.name))
print(ab.array)

```

უკვე ნახსენები მატრიცა მონაცემთა მასივის კერძო, ორგანზომილებიან შემთხვევას წარმოადგენს. წინა მაგალითში ცალკე აღებული ელემენტები `Thomas Anderson` და `Neo` მატრიცებია. მატრიცის აგება მონაცემთა მასივის მსგავსია:

```{r}
my.matrix <- matrix(c(1:15), nrow=5)
print(my.matrix)

```

წინამდებარე მაგალითში მივუთითეთ, თუ რამდენი სტრიქონი უნდა ჰქონოდა მატრიცას. შესაძლებელია მხოლოდ სვეტების მითითებაც:

```{r}
my.matrix <- matrix(c(1:15), ncol=5)
print(my.matrix)

```
მსგავსად მონაცემთა მასივისა, განზომილებების (ანუ სვეტების და სტრიქონების) სახელები მატრიცებსაც ენიჭება:

```{r}
col.names <- c("პირველი", "მეორე", "მესამე", "მეოთხე", "მეხუთე")
row.names <- c("სტრიქონი1", "სტრიქონი2", "სტრიქონი3")
my.matrix <- matrix(c(1:15), ncol=5, dimnames=list(row.names, col.names))
print(my.matrix)

```

##### მონაცემთა ჩარჩო

მონაცემთა ჩარჩო მატრიცის კერძო შემთხვევაა, რომელიც ყველაზე მეტად უახლოვდება თქვენთვის ნაცნობ ელექტრონული ცხრილის (spreadsheet) ფორმატს, ასევე STATA და SPSS მონაცემთა ბაზებს. მატრიცის მსგავსად, მონაცემთა ჩარჩოც ,,მართკუთხაა'', ე.ი. ორი განზომილება აქვს. თუმცა, საქმის გაადვილებისთვის, თითოეული სვეტი ცალკე ცვლადს წარმოადგენს, ხოლო სტრიქონი - შემთხვევას. ამასთან, თითოეულ სვეტში მსგავსი ტიპის მონაცემები უნდა ინახებოდეს (მაგ. მხოლოდ სიმბოლო, მთელი რიცხვი, ნამდვილი რიცხვი, ფაქტორი და ა.შ.). მონაცემთა ჩარჩოს აგება შეიძლება როგორც მატრიცების, ასევე ცალკეული სხვა ობიექტების კომბინირებით, მთავარია, მათი სიგრძე (ანუ სტრიქონების რაოდენობა) თანაბარი იყოს:

```{r}
df <- data.frame(
   my.id = c (1:11), 
   region.name = c("Samegrelo-Zemo Svaneti","Racha-Lechkhumi-Kvemo Svaneti","Imereti","Guria","Adjara", "Samtskhe-Javakheti", "Shida Kartli", "Kvemo Kartli", "Mtskheta-Mtianeti", "Tbilisi", "Kakheti"),
   value.added = c(1807.4, NA, 2685.2, 584.4, 2039.7, 724.6, 1485.21, 2162.9, NA, 12147.1, 1459.1),
   stringsAsFactors = FALSE
	)
print(df)

```

ამ მაგალითში შევქმენით `df` მონაცემთა ჩარჩო, რომელსაც სამი ცვლადი (სვეტი) და თერთმეტი ჩანაწერი გააჩნია. პირველი სვეტი `my.id` რეგიონის უნიკალურ კოდს აღნიშნავს, `region.name` - რეგიონის სახელს, ხოლო `value.added` - 2014 წლის მონაცემების მიხედვით, რეგიონში წარმოებული პროდუქციის დამატებულ ღირებულებას. ყურადღება მიაქციეთ იმას, რომ რაჭა-ლეჩხუმის და მცხეთა მთიანეთის შემთხვევაში მონაცემები არ მოიპოვება, ამიტომ რიცხვების შეტანისას ვიყენებთ ცარიელი ჩანაწერის აღნიშვნას NA (Not applicable).

#### ფუნქციები და ოპერატორები

```{r}
```


![](img/egh.gif)

R-გარემოში ყველა ძირითადი არითმეტიკული და ალგებრული ოპერაციის შესრულებაა შესაძლებელი. ოპერატორების აღმნიშვნელი სიმბოლოებიც სტანდარტულია:

| __ოპერატორი__ | __აღწერა__ |
|--------------|--------------------------------------------------------------------------------|
|	`+`		| შეკრება
|	`-` 	| გამოკლება|
|	`*`		| გამრავლება |
|	`/` | გაყოფა |
|	`**` ან `^`	| ახარისხება |
|	`abs` | აბსოლუტური მნიშვნელობა (მოდული) |
|	`sqrt`		| კვადრატული ფესვი |
|	`log`	| ნატურალური ლოგარითმი |
|	`log10`	| ლოგარითმი ათის ფუძით |
|	`exp`	| ლოგარითმის მაჩვენებლის (ექსპონენტის) გამოთვლა |
|	`sum`	| ვექტორთა ჯამის გამოთვლა |
|	`mean`	| ვექტორთა საშუალოს გამოთვლა |
|	`median`	| ვექტორთა მედიანური მნიშვნელობის გამოთვლა |7
|	`max`	| ვექტორთა მაქსიმუმის გამოთვლა |
|	`min`	| ვექტორთა მინიმუმის გამოთვლა |
|	`length`	| ვექტორში ელემენტების რაოდენობის გამოთვლა |

მოდი, ვნახოთ რამდენიმე მაგალითი:

```{r}
x <- c(10, 2, 45, 7, 89, 11)
abs(x)
sqrt(x)
log(x)
log10(x)
exp(x)
sum(x)
median(x)
mean(x)
max(x)
min(x)
	
```

მართალია, R-გარემოში სტანდარტული გადახრის გამოთვლის საკუთარი ფუნქცია არსებობს, მაგრამ ვნახოთ, როგორ შეიძლება იგივე დავალების ,,ხელით'' გამოყვანა. სტანდარტული გადახრის ფორმულა შემდეგნაირად გამოიყურება:

$s = \sqrt{\frac{1}{N-1} \sum_{i=1}^N (x_i - \overline{x})^2}$

დავუშვათ, რომ გვაქვს შემდეგი სიმრავლე:

```{r}
x <- c(1, 3, 4, 6, 9)

```

პირველ რიგში, შევასრულოთ ჯამის ქვეშ არსებული მოქმედება: გამოვთვალოთ ჯამის ქვეშ არსებული გამოსახულება (სიმრავლის ელემენტებისა და მათი საშუალოების სხვაობა) და ავიყვანოთ კვადრატში:

```{r}
my.mean <- mean(x) # გამოვთვალოთ საშუალოების
my.sum <- sum((x-my.mean)^2)

```

ახლა შევასრულოთ გამოსახულების დანარჩენი ნაწილები, სახელდობრ - გაყოფა და კვადრატული ფესვის ამოღება:

```{r}
my.stdev <- sqrt(my.sum/(length(x)-1))

```
ახლა გადავამოწმოთ, ემთხვევა თუ არა ჩვენს მიერ ჩატარებული გამოთვლები R-ის ჩაშენებულ ფუნქციას:

```{r}
sd(x)

print(my.stdev)

```

#### მონაცემთა დამუშავება

#### ქვესიმრავლის ამორჩევა

R-გარემოში ამორჩევის ოპერაცია საკმაოდ მოქნილია - მიღებული ქვესიმრავლე შეიძლება წარმოადგენდეს იმ მონაცემთა ერთობლიობას, სასურველ პირობას აკმაყოფილებს, ასევე ყველა ის მონაცემები, რომელიც ამ პირობას _არ აკმაყოფილებს_: ანუ შესაძლებელია, სტუდენტთა სიაში ავარჩიოთ ყველა გიორგი, ან - ყველა სტუდენტი, გიორგების გამოკლებით. ჰედლი უიქჰემის [მიხედვით](http://adv-r.had.co.nz/Subsetting.html), R-გარემოში ამორჩევის სამი ოპერაცია არსებობს. მარტივი ამორჩევისთვის გამოიყენება `[` ოპერატორი, ხოლო უფრო რთულისთვის - `[[` ან `$`.

მოდი, განვიხილოთ, თუ როგორ ,,იქცევა'' `[` ოპერატორი მონაცემთა თითოეული ტიპის შემთხვევაში.

##### ატომური ვექტორები

დავუშვათ, რომ არსებობს შემდეგი ტიპის ვექტორი:

```{r}

atomic.vector <- c(2.5, 6.9, 0, 5.4)

```

ამორჩევის ოპერაცია `[` ოპერატორის გამოყენებით შემდეგნაირად გამოიყურება:

```{r}
atomic.vector[c(1, 3)] # ამოირჩევს ვექტორის პირველ და მესამე ჩანაწერებს

atomic.vector[order(atomic.vector)] # ვექტორის ჩანაწერებს ზრდის მიხედვით დაალაგებს

atomic.vector[-c(1, 3)] # ამოირჩევს ყველა ჩანაწერს, პირველი და მესამე ელემენტის გარდა

atomic.vector[atomic.vector > 0] # ამოირჩევს ყველა ჩანაწერს, რომელიც 0-ზე მეტია

```

რა თქმა უნდა, შესაძლებელია, რომ ამორჩევის შედეგები ცალკე ობიექტად შევინახოთ:

```{r}

new.vector <- atomic.vector[atomic.vector > 0]
print(new.vector)

```

##### მატრიცები და მონაცემთა ჩარჩოები

როგორც აღვნიშნეთ, მატრიცაც და მონაცემთა ჩარჩოც ორგანზომილებიანი ობიექტიებია, შესაბამისად, `[` ოპერატორის გამოყენებისას, აუცილებლად უნდა მივუთითოთ სვეტის ან სტრიქონის კოორდინატები:

```{r}
my.matrix <- matrix(1:12, ncol = 3)

# პირველი და მეორე სტრიქონის ამორჩევა
my.matrix[1:2, ]

# პირველი და მეორე სვეტის ამორჩევა
my.matrix[, 1:2]

```

უნდა გვახსოვდეს, რომ მატრიცებსა და მონაცემთა ჩარჩოებში, კოორდინატების მითითებისას, ჯერ სტრიქონების მახასიათებლები იწერება, ხოლო შემდეგ - სვეტის.

ახლა ვნახოთ, თუ როგორაა შესაძლებელი მონაცემების ამორჩევა კოორდინატების მითითების გარეშე:


```{r}
df <- data.frame(
   my.id = c (1:11), 
   region.name = c("Samegrelo-Zemo Svaneti","Racha-Lechkhumi-Kvemo Svaneti","Imereti","Guria","Adjara", "Samtskhe-Javakheti", "Shida Kartli", "Kvemo Kartli", "Mtskheta-Mtianeti", "Tbilisi", "Kakheti"),
   value.added = c(1807.4, NA, 2685.2, 584.4, 2039.7, 724.6, 1485.21, 2162.9, NA, 12147.1, 1459.1),
   stringsAsFactors = FALSE
	)

df[which(df$region.name == "Shida Kartli"), ] # მხოლოდ შიდა ქართლის ამორჩევა

df[which(df$value.added > 1000), ] # მხარეები, სადაც შექმნილი დამატებული ღირებულება მილიარდ ლარს აღემატება

```

იმავე ოპერაციის შესრულება შესაძლებელია `subset` ფუნქციის განხორციელებით:

```{r}
subset(df, region.name == "Shida Kartli") # მხოლოდ შიდა ქართლის ამორჩევა

subset(df, value.added > 1000) # მხარეები, სადაც შექმნილი დამატებული ღირებულება მილიარდ ლარს აღემატება

```

`subset` ფუნქციის მეშვეობით შესაძლებელია, ამოვარჩიოთ არამხოლოდ სასურველი ჩანაწერები, არამედ - ცვლადებიც. წინა მაგალითში, თუკი მხოლოდ რეგიონების სახელწოდებების და მათი უნიკალური კოდების შენარჩუნება გვინდა, მაშინ სინტაქსი შემდეგ სახეს მიიღებს:

```{r}

subset(df, value.added > 1000, select=c(region.name, my.id)) # მხარეები, სადაც შექმნილი დამატებული ღირებულება მილიარდ ლარს აღემატება. არჩეულია მხოლოდ რეგიონის სახელწოდება და უნიკალური კოდი

```

#### მონაცემთა ჩასმა

მონაცემთა ჩასმა (ჩანაცვლება) გარკვეულწილად ამორჩევის ოპერაციების მსგავსია, თუმცა ამ შემთხვევაში, ამორჩეულ მონაცემებზე დამატებით, მინიჭების ოპერაციას ვიყენებთ.

მაგალითისთვის გამოვიყენებთ ფრენსის გალტონის ცნობილ მონაცემთა ბაზას. ამისთვის გადმოწერეთ და გაააქტიურეთ mosaicData ბიბლიოთეკა.

```{r}
install.packages("mosaicData")

library(mosaicData)

```

გალტონი, ცნობილი ბრიტანელი სტატისტიკოსი, გეოგრაფი, მკვლევარი (ასევე - ევგენიკის და რასიზმის აქტიური მხარდამჭერი), დაინტერესებული იყო, შეესწავლა, თუ რამდენად გადადის მემკვიდრეობით ბუნებრივი ნიშან-თვისებები. ამ მიზნით, მან ორასამდე ოჯახი გამოიკვლია და გაზომა მშობლებისა და შვილების სიმაღლეები. მოცემული მაგალითი `mosaicData`-ში არსებულ გალტონის ბაზას ემყარება.


```{r}
data(Galton) # ბაზის გამოძახება და გააქტიურება

names(data) # ვნახოთ, რა ცვლადები მოიპოვება ამ ბაზაში

# რა ტიპის ობიექტია Galton?


```
ბაზაში `height` ცვლადი აღნიშნავს ინდივიდის სიმაღლეს. მოდი, შევქმნათ ახალი ცვლადი, რომელიც `height`-ის ტოლია და ჩავანაცვლოთ მისი ყველა მნიშვნელობა, რომელიც 70-ს აღემატება, 999-ით:

```{r}
Galton$new.height <- Galton$height

Galton$new.height[Galton$new.height>70] <- 999

table(Galton$new.height)

```

დასაშვებია ორი ან მეტი პირობის არსებობა:

```{r}
Galton$new.height[Galton$new.height==999 | Galton$new.height== 65] <- 777

table(Galton$new.height)
```

#### შემთხვევით რიცხვთა გენერირების ალგორითმები

სხვადასხვა ამოცანის შესასრულებლად (მაგალითად, შერჩევისთვის), ხშირად გვჭირდება შემთხვევითი რიცხვების გენერირება. უნდა ითქვას, რომ კომპიუტერული პროგრამის მიერ გენერირებული რიცხვები [,,ფსევდოშემთხვევითია''](http://whatis.techtarget.com/definition/pseudo-random-number-generator-PRNG), ანუ გარკვეული ალგორითმის მიხედვით გამოთვლილი. R-გარემოში შესაძლებელია, სხვადასხვა განაწილების და თავისებურების მქონე შემთხვევითი რიცხვების ერთობლიობის გენერირება.

##### თანაბარი განაწილება


```{r, eval=FALSE}
runif(4) გამოითვლის თანაბარი განაწილების მქონე 4 რიცხვს

plotData <- runif(45)

unifH <- hist(plotData)

print(unifH)

```

##### ნორმალური განაწილება

```{r}

plotData <- rnorm(45)

unifH <- hist(plotData)

print(unifH)

```

კონკრეტული საშუალოს და სტანდარტული გადახრის მქონე განაწილების გენერირებისთვის საჭიროა, ეს პარამეტრები კოდში მივუთითოთ:

```{r}

plotData <- rnorm(45, mean=7, sd=3)

unifH <- hist(plotData)

print(unifH)

```

#### შერჩევა

შემთხვევითი შერჩევა `sample()` ფუნქციის მეშვეობით ხორციელდება. როგროც ზემოთ ვახსენეთ, მარტივი რიცხვები ,,ფსევდოშემთხვევითი'' ალგორითმებით გენერირდება, ამიტომ საჭიროა საწყისი რიცხვი, ე.წ. ძირი (seed), რომელსაც ეს ალგორითმი საწყის მნიშვნელობად აიღებს:

```{r}
set.seed(4)

myDf <- as.data.frame(rnorm(50, mean=7, sd=3))

mySample <- myDf[sample(1:nrow(myDf), 10), ]

```

შერჩევა შეიძლება იყოს _ჩაბრუნებული_ ან _ჩაუბრუნებელი_. ჩაბრუნებული შერჩევის შემთხვევაში, ამორჩეული რიცხვი უბრუნდება სიმრავლეს და შესაბამისად, შერჩევაში მოხვედრის ალბათობა არ იცვლება. ჩაუბრუნებელი შერჩვის შემთხვევაში, თითოეული ელემენტის ამოღებისას იცვლება მომდევნო ელემენტის ამოღებული ალბათობა:

<img src="img/swor_swr.png" alt="Drawing" style="width: 600px; display: block; margin-left: auto; margin-right: auto;"/>


```{r}
set.seed(4)

myDf <- as.data.frame(rnorm(50, mean=7, sd=3))

m.srswor <- myDf[sample(1:nrow(myDf), 10, replace=FALSE), ] # ჩაუბრუნებელი

m.srswr <- myDf[sample(1:nrow(myDf), 10, replace=FALSE), ] # ჩაბრუნებული

```
